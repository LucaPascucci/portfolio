<div class="container-fluid pt-3">
   <h2>Angular</h2>
   Framework per sviluppare “single-page application”, dove il codice viene totalmente scaricato sul client (migliore
   reattività) e solo i dati vengono scaricati in background.
   <br>
   Linguaggi utilizzati: Typescript (che viene compilato runtime in JavaScript), CSS, HTML

   <h3>Prerequisiti</h3>
   <ol>
      <li> NodeJS </li>
      <li> Installare AngularCLI → npm install -g @angular/cli </li>
   </ol>

   <h3>Astrazioni</h3>
   <ul>
      <li><b>Modulo (Module)</b>: Un modulo è il contenitore principale di angular, al suo interno è possibile inserire
         diversi componenti, servizi e richiedere l'utilizzi di altri moduli</li>
      <li><b>Componente (Component)</b>: Astrazione principale di angular attraverso i quali è possibile
         modularizzare le applicazioni complesse in componenti riutilizzabili e facili da gestire nel tempo.</li>
      <li><b>Servizio (Service)</b>: il compito principale del servizio è quello di repository centrale dove è possibile
         immagazzinare dati e/o delle funzionalità rendendole disponibili anche a componenti lontani tra loro</li>
   </ul>
   <ul ngbNav #nav="ngbNav" [(activeId)]="active" class="nav-tabs justify-content-center nav-fill">
      <li [ngbNavItem]="1">
         <a ngbNavLink>Modulo</a>
         <ng-template ngbNavContent>
            Un modulo è un meccanismo per raggruppare componenti, direttive, pipe e servizi correlati, in modo tale da
            poter
            esser combinato con altri moduli per creare un'applicazione.<br>
            Il decoratore che lo rappresenta è <b>@NgModule</b>
            <h4>Tipologie di moduli</h4>
            <ul>
               <li>Root → In ogni progetto è presente un <b>AppModule</b>, modulo utilizzato come modulo principale di
                  partenza
                  per avviare l'applicazione </li>
               <li>Features → Moduli specifici realizzati per l'applicazione</li>
            </ul>
            <pre
               class="p-3"><code [highlight]="codeModule" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>

            <h4>Custom Module</h4>
            Esempio di module features dove è che contiene un componente e servizio custom. La proprietà <b>export</b>
            serve a
            definire quali componenti rendere utilizzabili dall'esterno
            <pre
               class="p-3"><code [highlight]="codeModuleExport" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>
         </ng-template>
      </li>
      <li [ngbNavItem]="2">
         <a ngbNavLink>Data Binding</a>
         <ng-template ngbNavContent>
            Modalità di comunicazione tra il codice typescript (logica dell’applicazione) e il template HTML. L’unica
            parte visibile all’utente è il template HTML.<br>
            Due modalità di comunicazione:
            <ul>
               <li>OutputData (informazioni da Typescript → Template HTML)</li>
               <ul>
                  <li>String interpolation</li>
                  <li>Property binding</li>
               </ul>
               <li>React to (user) events (eventi da HTML → Typescript)</li>
               <ul>
                  <li>Event Binding</li>
               </ul>
            </ul>
            <h4>String Interpolation</h4>
            Passare una informazione definita su typescript direttamente al template HTML
            <pre
               class="p-3"><code [highlight]="codeStringInterpolation" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h4>Property Binding</h4>
            Passare una informazione definita su typescript ad una proprietà di un tag template HTML
            <pre
               class="p-3"><code [highlight]="codePropertyBinding" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h4>Event Binding</h4>
            Associazione di un evento, scatenato da un tag HTML, ad una funzione definita su typescript
            <pre
               class="p-3"><code [highlight]="codeEventBinding" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>
            La variabile <b>$event</b> contiene tutte informazioni scatenate dall’evento del tag HTML

            <h4>Two-Way Binding</h4>
            Possibilità di unire le due modalità di comunicazione e reagire contemporaneamente agli eventi generati
            dall’utente tramite l’interazione con il template HTML e alle informazioni generate da una computazione nel
            typescript.<br>
            Lato Typescript
            <pre
               class="p-3"><code [highlight]="codeTwoWayBindingTypescript" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>
            Lato HTML
            <pre
               class="p-3"><code [highlight]="codeTwoWayBindingHTML" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>
            Effetti: Precarica il contenuto della variabile su typescript nel tag HTML (outputData) + reagisce agli
            eventi di
            modifica (user input event) cambiando dinamicamente il valore della variabile su typescript.
         </ng-template>
      </li>
      <li [ngbNavItem]="3">
         <a ngbNavLink>Componente</a>
         <ng-template ngbNavContent>
            I component sono l’astrazione principale di angular attraverso i quali è possibile modularizzare le
            applicazioni
            complesse in componenti riutilizzabili e facili da gestire nel tempo.<br>
            <b>APP.COMPONENT → component principale (root) di ogni progetto Angular</b><br>
            <h4>Struttura</h4>
            <ul>
               <li>nome.component.ts: file typescript che contiene la logica. Al suo interno è specificato il tag HTML
                  per
                  utilizzarlo</li>
               <li>nome.component.html: file HTML che contiene il template da renderizzare</li>
               <li>nome.component.css: file CSS dove definire lo stile del componente</li>
            </ul>
            <h4>Property Binding da PADRE a FIGLIO</h4>
            Per passare informazioni dal componente "padre" al componente "figlio".<br>
            Nel Typescript del figlio
            <pre
               class="p-3"><code [highlight]="codePropertyBindingFiglio" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>

            Nel template HTML del padre
            <pre
               class="p-3"><code [highlight]="codePropertyBindingPadre" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h4>Event binding da FIGLIO a PADRE</h4>
            Per passare informazioni dal componente "padre" al componente "figlio".<br>
            Nel Typescript del figlio
            <pre
               class="p-3"><code [highlight]="codeEventBindingFiglio" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>

            Nel template HTML del padre
            <pre
               class="p-3"><code [highlight]="codeEventBindingPadre" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h4>Lifecycle</h4>
            <ol>
               <li><b>constructor</b></li>
               <li><b>ngOnChanges</b>: invocato quando una <b>Property Binding</b> è cambiata</li>
               <li><b>ngOnInit</b>: invocato <b>solamente una volta</b>, quando il component è inizializzato ma non
                  ancora
                  aggiunto al DOM</li>
               <li><b>ngDoCheck</b>: invocata a seguito di ogni <b>Change Detection</b></li>
               <li><b>ngAfterContentInit</b>: invocato al completamento della proiezione di &#60;ng-content&#62;</li>
               <li><b>ngAfterContentChecked</b>: invocato ogni volta che un &#60;ng-content&#62; è stato controllato
               </li>
               <li><b>ngAfterViewInit</b>: invocato dopo che il template HTML del component + eventuali figli sono
                  stati renderizzati</li>
               <li><b>ngAfterViewChecked</b>: invocato ogni volta che il template HTML del component + eventuali figli
                  sono stati
                  controllati</li>
               <li><b>ngOnDestroy</b>: invocato prima che il componente venga distrutto. Fare UNSUBSCRIBE degli
                  Observable!!!
               </li>
            </ol>
         </ng-template>
      </li>
      <li [ngbNavItem]="4">
         <a ngbNavLink>Direttive</a>
         <ng-template ngbNavContent>
            Sono istruzioni nel DOM (template HTML), ci sono direttive date da Angular ed è possibile creare
            delle proprie custom directives. Sono utili appunto per modificare dinamicamente il template HTML
            visualizzato dall’utente.

            <h4>Direttive strutturali - </h4>
            Modificano la struttura del DOM attraverso aggiunta o rimozione di tag HTML

            <h5>*ngIf</h5>
            Utile per definire quale parte del template HTML visualizzare in base ad una condizione
            <pre
               class="p-3"><code [highlight]="codeNgIf" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h5>*ngFor</h5>
            Utile per replicare dinamicamente una parte del template HTML ciclando su un array dichiarato nel typescript
            <pre
               class="p-3"><code [highlight]="codeNgFor" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h5>*ngSwitch</h5>
            Utile per decidere quale parte di template HTML utilizzare in base al valore di una variabile typescript
            <pre
               class="p-3"><code [highlight]="codeNgSwitch" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h5>ngStyle</h5>

            <h5>ngClass</h5>

            <h4>Custom directive</h4>
         </ng-template>
      </li>
      <li [ngbNavItem]="5">
         <a ngbNavLink>Servizi</a>
         <ng-template ngbNavContent>
            Il service è una parte del progetto Angular che lavora come repository centrale dove è possibile
            immagazzinare dati e/o delle funzionalità
            <h4>Dove istanziare i servizi</h4>
            <ul>
               <li><b>AppModule</b>: Un servizio istanziato a questo livello sarà disponibile in tutta l'applicazione,
                  <b>anche
                     ad altri servizi</b> (STESSA ISTANZA)</li>
               <li><b>AppComponent</b>: Un servizio istanziato a questo livello sarà disponibile a tutti componenti ma
                  <b>non ad altri servizi</b></li>
               <li><b>CustomComponent</b>: Un servizio istanziato a questo livello sarà disponibile a tutti componenti
                  figli</li>
            </ul>
            Per mantenere la stessa istanza di un Service all'interno dell'applicazione è necessario aggiungerlo ai
            provider solo nel Componente dove si vuole istanziare il servizio che poi sarà utilizzabile a tutti i sotto
            componenti oppure inserirlo direttamente nel AppModule

            <h4>Realizzare un servizio</h4>
            <pre
               class="p-3"><code [highlight]="codeService" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>
            <hr>
         </ng-template>
      </li>
      <li [ngbNavItem]="7">
         <a ngbNavLink>Routing</a>
         <ng-template ngbNavContent>
            Utile per navigare tra più "component" senza averli tutti in una singola pagina.
            <pre
               class="p-3"><code [highlight]="codeRoutes" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>

            <h4>Absolute Path (/)</h4>
            Utilizza sempre l’URL di default (localhost:4200) e poi aggiunge il path specificato in routerLink
            <pre
               class="p-3"><code [highlight]="codeRouterAbsolutePath" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>
            <h4>Relative Path (./)</h4>
            Aggiungerà sempre all’indirizzo URL corrente il path specificato in routerLink
            <pre
               class="p-3"><code [highlight]="codeRouterRelativePath" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h4>Caso speciale ( ../)</h4>
            Dal URL corrente effettua un salto indietro eliminando la parte finale di path e aggiunge la route (
            nomeRoute )
            definita
            <pre
               class="p-3"><code [highlight]="codeRouterSpecialPath" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h4>Utilizzare Router in Typescript</h4>
            Attraverso la classe Router è possibile navigare tra le route, definite nel app.module.ts, direttamente nel
            typescript.
         </ng-template>
      </li>
      <li [ngbNavItem]="8">
         <a ngbNavLink>Forms</a>
         <ng-template ngbNavContent>
            <h4>Template Driven Form</h4>
            Hanno un ngModel nel mezzo che raccoglie tutti i dati della form. Le modifiche dei valori wrappati sono
            asincrone, lo
            si può notare durante i test (inserimento di valori tramite HTML).

            <h4>Reactive Form</h4>
            Offrono più features --> ogni campo di input ha il suo form control dal quale è possibile gestirlo e le
            modifiche
            sono sincrone quindi è più semplice da controllare e testare.<br>

            <h5>Classi utilizzate</h5>
            <ul>
               <li>Form Builder</li>
               <li>Form Group</li>
               <li>Form Control</li>
               <li>Form Array</li>
               <li>Validators</li>
            </ul>

            <h5>Possibili stati della Form o di ogni singolo campo</h5>
            <ul>
               <li>dirty --> true / false</li>
               <li>touched --> true / false</li>
               <li>untouched --> true / false</li>
               <li>valid --> true / false</li>
               <li>invalid --> true / false</li>
               <li>value --> json</li>
               <li>status --> valid / invalid</li>
            </ul>

            <h5>Realizzazione</h5>
            Dobbiamo creare un modello che rappresenti la struttura del DOM nel nostro componente. Possiamo fare questo
            sfruttando i componenti di sistema FormGroup e FormControl, come mostrato nel seguente esempio:
            <pre
               class="p-3"><code [highlight]="codeReactiveFormComponent" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>
            A questo punto non ci resta che mettere in relazione quanto definito tramite codice con il markup del
            template
            associato. Ricordarsi anche di importare ReactiveFormsModule nel AppModule
            <pre
               class="p-3"><code [highlight]="codeReactiveFormTemplate" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>

            <h5>Accedere al contenuto della form</h5>
            La proprietà myForm.value conterrà un oggetto composto dai valori attualmente presenti sulla form. In
            alternativa
            possiamo accedere ai singoli controlli della form sfruttando la proprietà controls di myForm
            <pre
               class="p-3"><code [highlight]="codeReactiveFormValues" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>

            <h5>Definizione di form con FormBuilder + Validatori</h5>
            Un approccio più compatto per definire una form è basato sull’uso di FormBuilder. Il seguente codice produce
            lo
            stesso effetto del codice precedente, ma è molto più sintetico:
            <pre
               class="p-3"><code [highlight]="codeReactiveFormBuilder" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>
            Importando il componente di sistema <b>Validators</b> abbiamo accesso ai validatori predefiniti di Angular.
            Nel
            nostro caso, il validatore <b>Validators.required</b> rende valido il controllo quando l’utente ha inserito
            un
            valore.<br>
            Possiamo dare un feedback all’utente sulla validità del controllo direttamente nel markup come nel seguente
            esempio:
            <pre
               class="p-3"><code [highlight]="codeReactiveFormFeedback" [lineNumbers]="lineNumbers" [languages]="['html']"></code></pre>
            <h5>Catturare le modifiche della form</h5>
            le Reactive Form mettono a disposizione la proprietà valueChanges, che implementa il pattern
            Publisher-Subscriber e
            ci avvisa quando viene effettuata una qualsiasi modifica alla form o ad uno specifico controllo della form.
            <pre
               class="p-3"><code [highlight]="codeReactiveFormValuesChanges" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>
         </ng-template>
      </li>
      <li [ngbNavItem]="9">
         <a ngbNavLink>Richieste HTTP, API, servizi asincroni</a>
         <ng-template ngbNavContent>
            Per prima cosa importiamo <b>HttpModule</b> all’interno del file di definizione del modulo della nostra
            applicazione,
            <b>app.module.ts</b> <br>

            Nel servizio di effettua crea un metodo che restituisce il risultato della richiesta HTTP.
            <pre
               class="p-3"><code [highlight]="codeServiceObservable" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>

            Nel component viene richiamato il metodo del servizio e fatto subscribe dell'observable:
            <pre
               class="p-3"><code [highlight]="codeComponentObservable" [lineNumbers]="lineNumbers" [languages]="['typescript']"></code></pre>

            <h4>Operatori disponibili per gli Observable</h4>
            <ul>
               <li><b>filter</b>: Filtra i valori restituiti da un Observable in base ad una condizione booleana
                  specificata.
                  ESEMPIO: filter(x => x % 2 == 0)</li>
               <li><b>interval</b>: Restituisce un Observable che genera un valore numerico ad ogni intervallo di tempo
                  prefissato espresso in millisecondi. ESEMPIO: interval(1000)</li>
               <li><b>last</b>: Restituisce un Observable che contiene l’ultimo valore generato dall’Observable
                  originario.</li>
               <li><b>max</b>: Restituisce il valore massimo generato da un Observable </li>
               <li><b>merge</b>: Combina più Observable creandone uno che restituisce i valori asincroni generati da
                  ciascuno di
                  essi. ESEMPIO: mergedObservable = observ1.merge(observ2, observ3);</li>
               <li><b>concat</b>: Restituisce un Observable che concatena i valori restituiti da due o più Observable.
                  ESEMPIO:
                  concatObservable = observ1.concat(observ2, observ3);</li>
               <li><b>retry</b>: Restituisce un Observable identico all’originale sul quale, in caso di errore, si
                  autoregistra
                  per rieseguire l’operazione asincrona fino ad un massimo stabilito dal parametro passato</li>
            </ul>
            <h4>Observables vs Promise</h4>
            <ul>
               <li><b>una Promise</b> è legata ad un solo evento asincrono e l’unica cosa che è possibile fare è gestire
                  il suo
                  successo o il fallimento;</li>
               <li><b>un Observable</b>, invece, è associato ad una sequenza di eventi che possono essere combinati ed
                  elaborati
                  tramite gli operatori di cui abbiamo già accennato. Grazie ad essi possiamo effettuare operazioni,
                  come ad
                  esempio la
                  riesecuzione di un’operazione asincrona fallita, difficilmente implementabili con le Promise.</li>
            </ul>

            <h5>Ricordarsi di fare unsubscribe di tutti gli observable nel OnDestroy!!! </h5>
         </ng-template>
      </li>
   </ul>
   <div [ngbNavOutlet]="nav" class="jumbotron p-3"></div>

   <h3>Documentazione</h3>
   Utilizzare <a href="https://compodoc.app/">CompoDoc</a> per generare la documentazione sul progetto Angular
   <hr>

   <h3>Link utili</h3>
   <ul>
      <li>
         <a href="https://angular.io/guide/cheatsheet">Angular - Cheat Sheet</a>
      </li>
      <li>
         <a href="https://indepth.dev/angular/">IN DEPTH - ANGULAR</a>
      </li>
      <li>
         <a href="https://github.com/mgechev/codelyzer#readme">Codelyzer - Static analysis for Angular projects</a>
      </li>
      <li>
         <a href="https://training.fabiobiondi.io/2018/04/14/dependency-injection-in-angular/">Dependency Injection</a>
      </li>
   </ul>
</div>
